/**
 * This is free and unencumbered software released into the public domain.

 Anyone is free to copy, modify, publish, use, compile, sell, or
 distribute this software, either in source code form or as a compiled
 binary, for any purpose, commercial or non-commercial, and by any
 means.

 In jurisdictions that recognize copyright laws, the author or authors
 of this software dedicate any and all copyright interest in the
 software to the public domain. We make this dedication for the benefit
 of the public at large and to the detriment of our heirs and
 successors. We intend this dedication to be an overt act of
 relinquishment in perpetuity of all present and future rights to this
 software under copyright law.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

 For more information, please refer to <http://unlicense.org/>
 */

import com.android.annotations.NonNull
import com.android.manifmerger.ManifestMerger2
import com.android.manifmerger.ManifestMerger2.Invoker
import com.android.manifmerger.ManifestMerger2.MergeType
import com.android.manifmerger.MergingReport
import com.android.manifmerger.PlaceholderEncoder
import com.android.manifmerger.XmlDocument
import com.android.utils.ILogger

import java.nio.charset.Charset

/**
 * Fat AAR Lib generator v 0.2.1
 * Target Gradle Version :: 2.2.0
 *
 * Latest version available at https://github.com/adwiv/android-fat-aar
 * Please report issues at https://github.com/adwiv/android-fat-aar/issues
 *
 * This code is in public domain.
 *
 * Use at your own risk and only if you understand what it does. You have been warned ! :-)
 */

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:manifest-merger:25.2.0'
    }
}

configurations {
    embedded
}

dependencies {
    compile configurations.embedded
}

// Paths to embedded jar files
ext.embeddedJars = new ArrayList<String>()
// Paths to embedded aar projects
ext.embeddedAarDirs = new ArrayList<String>()
// List of embedded R classes
ext.embeddedRClasses = new ArrayList<String>()

// Change backslash to forward slash on windows
ext.build_dir = buildDir.path.replace(File.separator, '/');

ext.exploded_aar_dir = "$build_dir/intermediates/exploded-aar";
ext.classs_release_dir = "$build_dir/intermediates/classes/release";
ext.bundle_release_dir = "$build_dir/intermediates/bundles/release";
ext.manifest_aaapt_dir = "$build_dir/intermediates/manifests/aapt/release";
ext.generated_rsrc_dir = "$build_dir/generated/source/r/release";

ext.jniso_copy_dir = ''

ext.base_r2x_dir = "$build_dir/fat-aar/release/";

afterEvaluate{
    println "-----------------------------------------------------------"
    println "buiid dir path : $build_dir"

    def dependencies = new ArrayList<ResolvedDependency>()
    configurations.embedded
            .resolvedConfiguration.firstLevelModuleDependencies.each {
        if(it.moduleGroup.contains('com.duanqu')){
            println it.moduleName
            dependencies.add(it)
        }
    }

    def otherdp = new ArrayList<ResolvedDependency>();

    def dependencyNames = new HashMap<String, String>()

    def pmap = new HashMap<String, Project>()
    getRootProject().allprojects.each {
        pmap.put(it.name, it)
    }

//    jniso_copy_dir =  pmap.get('Demo').buildDir.path.replace(File.separator, '/').replace("/.gradle-build", "") + '/src/main/libs'

//    println "--------------$jniso_copy_dir------------------"
//    file(jniso_copy_dir).listFiles().each {
//        delete it
//    }
    dependencies.each {
        println "-------------------------first add moduleName----------------------------------"
        println it.moduleName
        dependencyNames.put(it.moduleName, getProject().name)
    }

    dependencies.each {
        Project p = pmap.get(it.moduleName)
        if(p != null){
            println "-------------------------for each moduleName $p.name----------------------------------"
            def rds = new ArrayList<ResolvedDependency>((p.configurations.getByName("compile"))
                    .resolvedConfiguration.firstLevelModuleDependencies)

            rds.each {
                if(!dependencyNames.containsKey(it.moduleName)){
                    dependencyNames.put(it.moduleName, p.name)
                }
            }
            rds.each {
                if(!otherdp.contains(it)){
                    println it.moduleName
                    otherdp.add(it)
                }

                Project p1 = pmap.get(it.moduleName)
                if(p1 != null){
                    println "-------------------------for each moduleName second $p1.name----------------------------------"
                    def rds1 = new ArrayList<ResolvedDependency>((p1.configurations.getByName("compile"))
                            .resolvedConfiguration.firstLevelModuleDependencies)
                    rds1.each {
                        if(!dependencyNames.containsKey(it.moduleName)){
                            dependencyNames.put(it.moduleName, p1.name)
                        }
                    }
                    rds1.each {
                        if(!otherdp.contains(it)){
                            otherdp.add(it)
                            println it.moduleName
                        }
                        Project p2 = pmap.get(it.moduleName)
                        if(p2 != null){
                            println "-------------------------for each moduleName third $p2.name----------------------------------"
                            def rds2 = new ArrayList<ResolvedDependency>((p2.configurations.getByName("compile"))
                                    .resolvedConfiguration.firstLevelModuleDependencies)
                            rds2.each {
                                if(!dependencyNames.containsKey(it.moduleName)){
                                    dependencyNames.put(it.moduleName, p2.name)
                                }
                            }
                            rds2.each {
                                if(!otherdp.contains(it)){
                                    otherdp.add(it)
                                    println it.moduleName
                                }
                                Project p3 = pmap.get(it.moduleName)
                                if(p3 != null){
                                    println "-------------------------for each moduleName four $p3.name----------------------------------"
                                    def rds3 = new ArrayList<ResolvedDependency>((p3.configurations.getByName("compile"))
                                            .resolvedConfiguration.firstLevelModuleDependencies)
                                    rds3.each {
                                        if(!dependencyNames.containsKey(it.moduleName)){
                                            dependencyNames.put(it.moduleName, p3.name)
                                        }
                                    }
                                    rds3.each {
                                        if(!otherdp.contains(it)){
                                            otherdp.add(it)
                                            println it.moduleName
                                        }
                                    }
                                }
                            }
                        }


                    }
                }

            }
        }

    }

    println "-----------------------------------------------------------"
    otherdp.each {
        if(!dependencies.contains(it) && it.moduleGroup.contains('com.duanqu')){
            println it.moduleName
            dependencies.add(it)
        }
    }

    println "-----------------------------------------------------------"
    dependencies.reverseEach {
        def p = pmap.get(dependencyNames.get(it.moduleName))
        println it.moduleName
        println p == null ? "project null " : p.name
        if(p != null){
            it.moduleArtifacts.each {
                artifact ->
                    if (artifact.type == 'aar') {
                        def build_dir = p.buildDir.path.replace(File.separator, '/');
                        def exploded_aar_dir = "$build_dir/intermediates/exploded-aar"
                        def aarPath = "${exploded_aar_dir}/${it.moduleGroup}/${it.moduleName}/${it.moduleVersion}"

                        println aarPath
                        if (!embeddedAarDirs.contains(aarPath)) {
                            embeddedAarDirs.add(aarPath)
                        }
                    } else if (artifact.type == 'jar') {
                        def artifactPath = artifact.file.path.replace(File.separator, '/')
                        println(artifactPath)

                        if (!embeddedJars.contains(artifactPath)){
                            embeddedJars.add(artifactPath)
                        }
                    } else {
                        throw new Exception("Unhandled Artifact of type ${artifact.type}")
                    }
            }
        }
    }

//    def dependencies = new ArrayList((configurations.getByName("compile")).resolvedConfiguration.firstLevelModuleDependencies)
//    dependencies.reverseEach {
//        def aarPath = "${exploded_aar_dir}/${it.moduleGroup}/${it.moduleName}/${it.moduleVersion}"
//        println(aarPath)
//        it.moduleArtifacts.each {
//            artifact ->
//                if (artifact.type == 'aar') {
//                    if (!embeddedAarDirs.contains(aarPath)) {
//                        System.out.println(aarPath)
//                        embeddedAarDirs.add(aarPath)
//                    }
//                } else if (artifact.type == 'jar') {
//                    def artifactPath = artifact.file.path.replace(File.separator, '/')
////                    artifactPath = artifactPath.replace(File.separator, '/')
//                    if (!embeddedJars.contains(artifactPath)){
//                        System.out.println(artifactPath)
//                        embeddedJars.add(artifactPath)
//                    }
//                } else {
//                    throw new Exception("Unhandled Artifact of type ${artifact.type}")
//                }
//        }
//    }

    if (dependencies.size() > 0) {
        // Merge Assets
        generateReleaseAssets.dependsOn embedAssets
        embedAssets.dependsOn prepareReleaseDependencies

        // Embed Resources by overwriting the inputResourceSets
        packageReleaseResources.dependsOn embedLibraryResources
        embedLibraryResources.dependsOn prepareReleaseDependencies

        // Embed JNI Libraries
//        bundleRelease.dependsOn embedJniLibs
//        embedJniLibs.dependsOn transformNative_libsWithSyncJniLibsForRelease

        // Merge Embedded Manifests
        bundleRelease.dependsOn embedManifests
        embedManifests.dependsOn processReleaseManifest
        println "------------------------------------------------"
        println "Merge Embedded Manifests completed"
        println "------------------------------------------------"

        // Merge proguard files
        embedLibraryResources.dependsOn embedProguard
        embedProguard.dependsOn prepareReleaseDependencies
        println "------------------------------------------------"
        println "Merge proguard files completed"
        println "------------------------------------------------"

        // Generate R.java files
        compileReleaseJavaWithJavac.dependsOn generateRJava
        generateRJava.dependsOn processReleaseResources
        println "------------------------------------------------"
        println "Generate R.java files completed"
        println "------------------------------------------------"

        // Bundle the java classes
        bundleRelease.dependsOn embedJavaJars
        embedJavaJars.dependsOn compileReleaseJavaWithJavac
        println "------------------------------------------------"
        println "Bundle the java classes completed"
        println "------------------------------------------------"

        // If proguard is enabled, run the tasks that bundleRelease should depend on before proguard
        if (tasks.findByPath('proguardRelease') != null) {
            println "------------------------------------------------"
            println "proguardRelease embedJavaJars"
            println "------------------------------------------------"
            proguardRelease.dependsOn embedJavaJars
        } else if (tasks.findByPath('transformClassesAndResourcesWithProguardForRelease') != null) {
            println "------------------------------------------------"
            println "transformClassesAndResourcesWithProguardForRelease embedJavaJars"
            println "------------------------------------------------"
            transformClassesAndResourcesWithProguardForRelease.dependsOn embedJavaJars
        }
    }
}

task embedLibraryResources << {
    println "Running FAT-AAR Task :embedLibraryResources"

    def oldInputResourceSet = packageReleaseResources.inputResourceSets
    packageReleaseResources.conventionMapping.map("inputResourceSets") {
        getMergedInputResourceSets(oldInputResourceSet)
    }
    println "------------------------------------------------"
    println "Embed Resources by overwriting the inputResourceSets completed"
    println "------------------------------------------------"
}

private List getMergedInputResourceSets(List inputResourceSet) {
    //We need to do this trickery here since the class declared here and that used by the runtime
    //are different and results in class cast error
    def ResourceSetClass = inputResourceSet.get(0).class

    List newInputResourceSet = new ArrayList(inputResourceSet)

    embeddedAarDirs.each { aarPath ->
        try {
            String[] pecices = aarPath.split('/')
            def len = pecices.length
            String rn = null;
            for(int i = len - 3; i < len; i++){
                if(i != len - 1){
                    rn += pecices[i] + ':'
                }else{
                    rn += pecices[i]
                }
            }
            def resname = rn;
            def rs = ResourceSetClass.newInstance([resname, true] as Object[])
            rs.addSource(file("$aarPath/res"))
//            println "ResourceSet is " + rs
            newInputResourceSet += rs
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }

    return newInputResourceSet
}

/**
 * Assets are simple files, so just adding them to source set seems to work.
 */
task embedAssets << {
    println "Running FAT-AAR Task :embedAssets"
    embeddedAarDirs.each { aarPath ->
        // Merge Assets
        android.sourceSets.main.assets.srcDirs += file("$aarPath/assets")
    }

    println "------------------------------------------------"
    println "Merge Assets completed"
    println "------------------------------------------------"
}

/**
 * Merge proguard.txt files from all library modules
 * @author Marian Klühspies
 */
task embedProguard << {
    println "Running FAT-AAR Task :embedProguard"

    def proguardRelease = file("$bundle_release_dir/proguard.txt")
    embeddedAarDirs.each { aarPath ->
        try {
            def proguardLibFile = file("$aarPath/proguard.txt")
            if (proguardLibFile.exists())
                proguardRelease.append(proguardLibFile.text)
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }
}


task generateRJava << {
    println "Running FAT-AAR Task :generateRJava"

    // Now generate the R.java file for each embedded dependency
    def libPackageName = new XmlParser().parse(android.sourceSets.main.manifest.srcFile).@package

    embeddedAarDirs.each { aarPath ->

        def aarManifest = new XmlParser().parse(file("$aarPath/AndroidManifest.xml"));
        def aarPackageName = aarManifest.@package
        String packagePath = aarPackageName.replace('.', '/')

        // Generate the R.java file and map to current project's R.java
        // This will recreate the class file
        def rTxt = file("$aarPath/R.txt")
        def rMap = new ConfigObject()

        if (rTxt.exists()) {
            rTxt.eachLine {
                line ->
                    //noinspection GroovyUnusedAssignment
                    def (type, subclass, name, value) = line.tokenize(' ')
                    rMap[subclass].putAt(name, type)
            }
        }

        def sb = "package $aarPackageName;" << '\n' << '\n'
        sb << 'public final class R {' << '\n'

        rMap.each {
            subclass, values ->
                sb << "  public static final class $subclass {" << '\n'
                values.each {
                    name, type ->
                        sb << "    public static $type $name = ${libPackageName}.R.${subclass}.${name};" << '\n'
                }
                sb << "    }" << '\n'
        }

        sb << '}' << '\n'

        mkdir("$generated_rsrc_dir/$packagePath")
        file("$generated_rsrc_dir/$packagePath/R.java").write(sb.toString())

        embeddedRClasses += "$packagePath/R.class"
        embeddedRClasses += "$packagePath/R\$*.class"
    }
}

task collectRClass << {
    delete base_r2x_dir
    mkdir base_r2x_dir

    copy {
        from classs_release_dir
        include embeddedRClasses
        into base_r2x_dir
    }
}

task embedRClass(type: org.gradle.jvm.tasks.Jar, dependsOn: collectRClass) {
    destinationDir file("$bundle_release_dir/libs/")
    from base_r2x_dir
}

/**
 * To embed the class files, we need to change the R.class to X.class, so we explode it in another
 * location, proguard it to modify R to X, and then finally copy it to build location
 */
task embedJavaJars(dependsOn: embedRClass) << {
    println "Running FAT-AAR Task :embedJavaJars"

    embeddedAarDirs.each { aarPath ->
        // Explode all classes.jar files to classes so that they can be proguarded
        copy {
            println "copy aar classes jar ${aarPath} to ${classs_release_dir}"
            from zipTree("$aarPath/jars/classes.jar")
            into classs_release_dir
        }

        // Copy all additional jar files to bundle lib
        FileTree jars = fileTree(dir: "$aarPath/jars", include: '*.jar', exclude: 'classes.jar')
        jars += fileTree(dir: "$aarPath/jars/libs", include: '*.jar')
        jars += fileTree(dir: "$aarPath/libs", include: '*.jar')

        copy {
            println "copy jar ${jars} to ${bundle_release_dir}/libs"
            from jars
            into file("$bundle_release_dir/libs")
        }

        // Copy all embedded jar files to bundle lib
        copy {
            println "copy jar ${embeddedJars} to ${bundle_release_dir}/libs"
            from embeddedJars
            into file("$bundle_release_dir/libs")
        }
    }
}

/**
 * For some reason, adding to the jniLibs source set does not work. So we simply copy all files.
 */
task embedJniLibs << {
    println "Running FAT-AAR Task :embedJniLibs"

    embeddedAarDirs.each { aarPath ->
        println "======= Copying JNI from $aarPath/jni"
        // Copy JNI Folders
        copy {
            println jniso_copy_dir
            from fileTree(dir: "$aarPath/jni")
            into file(jniso_copy_dir)
        }
    }
}

task embedManifests << {
    println "Running FAT-AAR Task :embedManifests"

    ILogger mLogger = new MiLogger()
    List<File> libraryManifests = new ArrayList<>()

    embeddedAarDirs.each { aarPath ->
        if (!libraryManifests.contains(aarPath)) {
            libraryManifests.add(file("$aarPath/AndroidManifest.xml"))
            println "$aarPath/AndroidManifest.xml"
        }
    }

    File reportFile = file("${build_dir}/embedManifestReport.txt")

    File origManifest = file("$bundle_release_dir/AndroidManifest.xml")
    File copyManifest = file("$bundle_release_dir/AndroidManifest.orig.xml")
    File aaptManifest = file("$manifest_aaapt_dir/AndroidManifest.xml")

    copy {
        from origManifest.parentFile
        into copyManifest.parentFile
        include origManifest.name
        rename(origManifest.name, copyManifest.name)
    }

    try {
        Invoker manifestMergerInvoker = ManifestMerger2.newMerger(copyManifest, mLogger, MergeType.APPLICATION)

        manifestMergerInvoker.addLibraryManifests(libraryManifests.toArray(new File[libraryManifests.size()]))

//         manifestMergerInvoker.setPlaceHolderValues(placeHolders)
        manifestMergerInvoker.setMergeReportFile(reportFile);

        MergingReport mergingReport = manifestMergerInvoker.merge();

        mLogger.info("Merging result:" + mergingReport.getResult());
        MergingReport.Result result = mergingReport.getResult();
        switch (result) {
            case MergingReport.Result.WARNING:
                mergingReport.log(mLogger);
        // fall through since these are just warnings.
            case MergingReport.Result.SUCCESS:
                XmlDocument xmlDocument = mergingReport.getMergedXmlDocument(MergingReport.MergedManifestKind.MERGED);
                try {
                    String annotatedDocument = mergingReport.getActions().blame(xmlDocument);
                    mLogger.verbose(annotatedDocument);
                } catch (Exception e) {
                    mLogger.error(e, "cannot print resulting xml");
                }
                save(xmlDocument, origManifest);
                mLogger.info("Merged manifest saved to " + origManifest);
                if (aaptManifest.exists()) {
                    new PlaceholderEncoder().visit(xmlDocument);
                    save(xmlDocument, aaptManifest);
                    mLogger.info("Merged aapt safe manifest saved to " + aaptManifest);
                }
                break;
            case MergingReport.Result.ERROR:
                mergingReport.log(mLogger);
                throw new RuntimeException(mergingReport.getReportString());
            default:
                throw new RuntimeException("Unhandled result type : " + mergingReport.getResult());
        }
    } catch (RuntimeException e) {
        // Unacceptable error
        e.printStackTrace()
        throw new RuntimeException(e);
    }
}

private void save(XmlDocument xmlDocument, File out) {
    OutputStream outputStream = null;
    try {
        outputStream = openOutputStream(out, false);
        if(outputStream != null && xmlDocument.prettyPrint() != null) {}
        outputStream.write(getBytes(xmlDocument.prettyPrint(), Charset.forName("UTF-8")));
//        Files.write(xmlDocument.prettyPrint(), out,  Charset.forName("UTF-8"));
        outputStream.close();
    } catch (IOException e) {
        if(outputStream != null) {
            outputStream.close()
        }
        throw new RuntimeException(e);
    }
}

private byte[] getBytes(String src, Charset charSet) {
    return src.getBytes(charSet);
}

private FileOutputStream openOutputStream(File file, boolean append) throws IOException {
    if (file.exists()) {
        if (file.isDirectory()) {
            return null;
        }
        if (file.canWrite() == false) {
            return null;
        }
    } else {
        File parent = file.getParentFile();
        if (parent != null) {
            if (!parent.mkdirs() && !parent.isDirectory()) {
                return null;
            }
        }
    }
    return new FileOutputStream(file, append);
}

class MiLogger implements ILogger {

    @Override
    void error(
            @com.android.annotations.Nullable Throwable t,
            @com.android.annotations.Nullable String msgFormat, Object... args) {
        System.err.println(String.format("========== ERROR : " + msgFormat, args))
        if (t) t.printStackTrace(System.err)
    }

    @Override
    void warning(@NonNull String msgFormat, Object... args) {
        System.err.println(String.format("========== WARNING : " + msgFormat, args))
    }

    @Override
    void info(@NonNull String msgFormat, Object... args) {
        System.out.println(String.format("========== INFO : " + msgFormat, args))
    }

    @Override
    void verbose(@NonNull String msgFormat, Object... args) {
        // System.out.println(String.format("========== DEBUG : " + msgFormat, args))
    }

}
